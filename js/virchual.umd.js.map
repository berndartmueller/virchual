{"version":3,"file":"virchual.umd.js","sources":["../../src/utils/event.ts","../../src/components/controls/controls.ts","../../src/utils/utils.ts","../../src/components/lazyload-image/lazyload-image.ts","../../src/drag.ts","../../src/constants.ts","../../src/pagination.ts","../../src/slide.ts","../../src/utils/dom.ts","../../src/utils/sliding-window.ts","../../entry/entry-complete.ts","../../src/virchual.ts","../../src/utils/error.ts"],"sourcesContent":["export function stop(e: MouseEvent | TouchEvent) {\n  if (!e) return;\n\n  if (e.cancelable) {\n    e.preventDefault();\n  }\n\n  e.stopImmediatePropagation();\n  e.stopPropagation();\n}\n\nexport type EventHandler = (...args: unknown[]) => void;\nexport type EventTarget = (Window & typeof globalThis) | Element;\nexport type EventOptions = boolean | AddEventListenerOptions;\n\nexport class Event {\n  /**\n   * Store all event this.data.\n   */\n  private _handlers: Array<{\n    event: string;\n    handler: EventHandler;\n    elm: EventTarget;\n    opts: EventOptions;\n  }> = [];\n\n  /**\n   * Subscribe the given event(s).\n   *\n   * @param events  - An event name. Use space to separate multiple events.\n   *                  Also, namespace is accepted by dot, such as 'resize.{namespace}'.\n   * @param handler - A callback function.\n   * @param element - Optional. Native event will be listened to when this arg is provided.\n   * @param opts - Optional. Options for addEventListener.\n   */\n  on(events: string, handler: EventHandler, element?: EventTarget, opts?: EventOptions): Event;\n  on(events: { [event: string]: EventHandler }, element?: EventTarget, opts?: EventOptions): Event;\n  on(\n    events: string | { [event: string]: EventHandler },\n    handler?: EventHandler | EventTarget,\n    element?: EventTarget | EventOptions,\n    opts: EventOptions = {},\n  ): Event {\n    if (typeof events === 'string') {\n      events.split(' ').forEach(event => this._addEvent(event, element as EventTarget, handler as EventHandler, opts));\n    } else {\n      for (const event in events) {\n        this._addEvent(event, handler as EventTarget, events[event], opts);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Unsubscribe the given event(s).\n   *\n   * @param events - A event name or names split by space.\n   * @param element - Optional. removeEventListener() will be called when this arg is provided.\n   */\n  off(events: string, handler: EventHandler, element?: EventTarget): Event;\n  off(events: { [event: string]: EventHandler }, element?: EventTarget): Event;\n  off(events: string | { [event: string]: EventHandler }, element?: EventTarget | EventHandler, target?: EventTarget): Event {\n    if (typeof events === 'string') {\n      events.split(' ').forEach(event => this._removeEvent(event, target, element as EventHandler));\n    } else {\n      for (const event in events) {\n        this._removeEvent(event, element as EventTarget, events[event]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit an event.\n   * This method is only for custom events.\n   *\n   * @param event - An event name.\n   * @param args  - Any number of arguments passed to handlers.\n   */\n  emit(event: string, ...args: unknown[]) {\n    this._handlers.forEach(item => {\n      if (!item.elm && item.event.split('.')[0] === event) {\n        item.handler(...args);\n      }\n    });\n  }\n\n  /**\n   * Clear event this.data.\n   */\n  destroy() {\n    this._handlers.forEach(this._unroll);\n    this._handlers = [];\n  }\n\n  /**\n   * Remove the registered event listener.\n   *\n   * @param item - An object containing event this.data.\n   */\n  private _unroll(item: Event['_handlers'][0]) {\n    item.elm && item.elm.removeEventListener(item.event, item.handler, item.opts);\n  }\n\n  private _addEvent(event: string, element: EventTarget, handler: EventHandler, opts: EventOptions) {\n    element && element.addEventListener(event, handler, opts);\n\n    this._handlers.push({ event, handler: handler as EventHandler, elm: element as EventTarget, opts: opts });\n  }\n\n  private _removeEvent(event: string, element: EventTarget, handler: EventHandler) {\n    this._handlers = this._handlers.filter(item => {\n      if (item && item.event === event && item.handler === handler && item.elm === element) {\n        this._unroll(item);\n\n        return false;\n      }\n\n      return true;\n    });\n  }\n}\n","import { stop } from '../../utils/event';\nimport { ComponentDependencies } from './../component';\n\nexport type ControlsSettings = { isEnabled?: boolean };\n\nexport class Controls {\n  private _controls: HTMLButtonElement[];\n\n  constructor(private _imports: ComponentDependencies, private _settings?: ControlsSettings) {\n    this._controls = [].slice.call(_imports.virchual.container.querySelectorAll('.virchual__control'));\n\n    this.mount();\n  }\n\n  mount(): void {\n    this._controls.forEach(button => this._imports.eventBus.on('click', this._onClick, button));\n  }\n\n  private _onClick = (event: MouseEvent) => {\n    stop(event);\n\n    const button: HTMLButtonElement = (event.target as Element).closest('button') as HTMLButtonElement;\n    const control = button.dataset.controls as 'prev' | 'next';\n\n    if (control === 'prev') {\n      this._imports.virchual.prev();\n\n      return;\n    }\n\n    this._imports.virchual.next();\n  };\n}\n","import { identity } from './../types';\nexport function range(start: number, end: number): number[] {\n  return Array(end - start + 1)\n    .fill(0)\n    .map((_, idx) => start + idx);\n}\n\n/*\n * Rewind the given index if it's out of range.\n *\n * @param index - An index.\n * @param edge - Edge\n *\n * @return A rewound index.\n */\nexport function rewind(index: number, edge: number): number {\n  if (index > edge) {\n    return 0;\n  }\n\n  if (index < 0) {\n    return edge;\n  }\n\n  return index;\n}\n\n/**\n * Request animation frame wrapper.\n */\nexport function raf(callback: identity) {\n  return requestAnimationFrame(callback);\n}\n\n/**\n * Delay execution of given callback function.\n * Basically a wrapper around `window.setTimeout()`\n *\n * @param callback Callback function.\n * @param ms Delay in milliseconds.\n */\nexport function delay(callback: identity, ms: number) {\n  return setTimeout(callback, ms);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n","import { range, slidingWindow } from '@virchual/utils/index';\nimport { ComponentDependencies } from './../component';\n\nexport type LazyLoadImageSettings = {\n  /**\n   * Enables lazyloading imagest that are currently not visible, thus saving bandwidth.\n   */\n  lazyload?: boolean;\n\n  /**\n   * The CSS selector for lazyloaded images. Default 'img,picture'\n   */\n  lazyloadSelector?: string;\n};\n\nconst LAZY_CLASSNAME = 'virchual__lazy';\nconst LOADING_CLASSNAME = `${LAZY_CLASSNAME}--loading`;\nconst ERROR_CLASSNAME = `${LAZY_CLASSNAME}--failed`;\nconst COMPLETE_CLASSNAME = `${LAZY_CLASSNAME}--loaded`;\n\n/**\n * Return true if given elemen is a <picture> tag.\n *\n * @param element HTML Element.\n */\nfunction isPictureTag(element: HTMLElement): boolean {\n  return element && element.nodeName.toLowerCase() === 'picture';\n}\n\n/**\n * Return either parent <picture> tag or <img> tag.\n *\n * @param element Image HTML tag.\n */\nfunction getImage(image: HTMLImageElement | HTMLPictureElement): HTMLImageElement | HTMLPictureElement {\n  const picture = image.parentNode as HTMLElement;\n\n  if (isPictureTag(picture)) {\n    return picture;\n  }\n\n  return image;\n}\n\nexport class LazyLoadImage {\n  private _lazyload: boolean;\n  private _lazyloadSelector: string;\n\n  constructor(private _imports: ComponentDependencies, _settings: LazyLoadImageSettings) {\n    const { lazyload, lazyloadSelector } = {\n      lazyload: true,\n      lazyloadSelector: 'img,picture',\n      ..._settings,\n    };\n\n    this._lazyload = lazyload;\n    this._lazyloadSelector = lazyloadSelector;\n\n    // exit in case lazy loading is disabled\n    if (!this._lazyload) {\n      return;\n    }\n\n    _imports.eventBus.on({\n      mounted: () => {\n        this._doLazyLoad();\n      },\n      move: () => {\n        this._doLazyLoad();\n      },\n    });\n  }\n\n  /**\n   * Lazy load images.\n   */\n  private _doLazyLoad(): void {\n    const images = this._getImages();\n\n    images.forEach(image => this._loadImage(image));\n  }\n\n  /**\n   * Get all image tags (<img>, <picture>) to lazy load.\n   */\n  private _getImages() {\n    const indices = range(0, this._imports.virchual.getSlides(true).length - 1);\n    const slidesWindowIndices = slidingWindow(indices, this._imports.virchual.currentIndex, 1);\n\n    const images: Array<HTMLImageElement | HTMLPictureElement> = [];\n\n    slidesWindowIndices.forEach(index => {\n      const slide = this._imports.virchual.getSlides(true)[index];\n\n      if (!slide.isMounted) {\n        return;\n      }\n\n      [].forEach.call(slide.ref.querySelectorAll(this._lazyloadSelector), (img: HTMLElement) => {\n        // skip <img> tags within <picture> tags\n        if (isPictureTag(img.parentElement)) {\n          return;\n        }\n\n        images.push(img);\n      });\n    });\n\n    return images;\n  }\n\n  /**\n   * Do the actual lazy loading for a given image.\n   *\n   * @param image Either <img> or <picture> tag.\n   */\n  private _loadImage(image: HTMLImageElement | HTMLPictureElement) {\n    let hasLazyImages = false;\n\n    [].forEach.call(image.querySelectorAll('img,source'), (source: HTMLImageElement | HTMLSourceElement) => {\n      const srcSetData = source.dataset.srcset;\n      const srcData = source.dataset.src;\n\n      if (srcSetData) {\n        source.setAttribute('srcset', srcSetData);\n        source.removeAttribute('data-srcset');\n      }\n\n      // source is <img>\n      if (srcData) {\n        source.setAttribute('src', source.dataset.src);\n        source.removeAttribute('data-src');\n\n        this._imports.eventBus.on(this._getEvents(), source);\n      }\n\n      if (srcSetData || srcData) {\n        hasLazyImages = true;\n      }\n    });\n\n    if (hasLazyImages) {\n      image.classList.add(LAZY_CLASSNAME);\n      image.classList.add(LOADING_CLASSNAME);\n    }\n  }\n\n  private _onLoad = (event: Event) => {\n    const image = event.target as HTMLImageElement;\n\n    this._completeLoading(image);\n  };\n\n  private _onError = (event: Event) => {\n    const image = event.target as HTMLImageElement;\n    const target = getImage(image);\n\n    target.classList.add(ERROR_CLASSNAME);\n\n    this._completeLoading(image);\n  };\n\n  private _getEvents() {\n    return {\n      load: this._onLoad,\n      error: this._onError,\n    };\n  }\n\n  private _completeLoading(image: HTMLImageElement) {\n    const target = getImage(image);\n\n    target.classList.remove(LOADING_CLASSNAME);\n    target.classList.add(COMPLETE_CLASSNAME);\n\n    this._imports.eventBus.off(this._getEvents(), image);\n  }\n}\n","import { Event, stop } from './utils/event';\n\nexport class Drag {\n  // Analyzed info on starting drag.\n  private _startInfo;\n\n  // Analyzed info being updated while dragging/swiping.\n  private _currentInfo;\n\n  // Determine whether slides are being dragged or not.\n  private _isDragging = false;\n\n  private _eventBus: Event;\n  constructor(private _frame: HTMLElement, { event }: { event: Event }) {\n    this._eventBus = event;\n  }\n\n  mount() {\n    this._eventBus.on('touchstart mousedown', this._onStart, this._frame, { passive: true });\n    this._eventBus.on('touchmove mousemove', this._onMove, this._frame, { passive: false });\n    this._eventBus.on('touchend touchcancel mouseleave mouseup dragend', this._onEnd, this._frame);\n  }\n\n  /**\n   * Called when the track starts to be dragged.\n   */\n  private _onStart = (event: MouseEvent & TouchEvent) => {\n    if (!this._isDragging) {\n      this._startInfo = this._analyze(event, {});\n\n      this._currentInfo = this._startInfo;\n\n      this._eventBus.emit('dragstart', this._currentInfo);\n    }\n  };\n\n  private _onMove = (event: MouseEvent & TouchEvent) => {\n    if (!this._startInfo) {\n      return;\n    }\n\n    this._currentInfo = this._analyze(event, this._startInfo);\n\n    if (this._isDragging) {\n      stop(event);\n\n      this._eventBus.emit('drag', this._currentInfo);\n    } else {\n      if (this._shouldMove(this._currentInfo)) {\n        this._eventBus.emit('drag', this._currentInfo);\n\n        this._isDragging = true;\n      }\n    }\n  };\n\n  /**\n   * Called when dragging ends.\n   */\n  private _onEnd = () => {\n    this._startInfo = null;\n\n    if (this._isDragging) {\n      this._goTo(this._currentInfo);\n\n      this._isDragging = false;\n    }\n  };\n\n  /**\n   * Determine whether to start moving the track or not by drag angle.\n   *\n   * @param info - An information object.\n   *\n   * @return True if the track should be moved or false if not.\n   */\n  private _shouldMove({ offset }) {\n    const angle = (Math.atan(Math.abs(offset.y) / Math.abs(offset.x)) * 180) / Math.PI;\n\n    const dragAngleThreshold = 45;\n\n    return angle < dragAngleThreshold;\n  }\n\n  /**\n   * Go to the slide determined by the analyzed data.\n   *\n   * @param info - An info object.\n   */\n  private _goTo(info) {\n    const velocity = info.velocity['x'];\n    const absV = Math.abs(velocity);\n\n    if (absV > 0) {\n      this._eventBus.emit('dragend', this._currentInfo);\n    }\n  }\n\n  /**\n   * Analyze the given event object and return important information for handling swipe behavior.\n   *\n   * @param event          - Touch or Mouse event object.\n   * @param startInfo  - Information analyzed on start for calculating difference from the current one.\n   *\n   * @return - An object containing analyzed information, such as offset, velocity, etc.\n   */\n  private _analyze(\n    event: MouseEvent & TouchEvent,\n    startInfo,\n  ): {\n    to: { x: number; y: number };\n    offset: { x: number; y: number };\n    velocity: { x: number; y: number };\n    time: number;\n    control: 'prev' | 'next';\n  } {\n    const { timeStamp, touches } = event;\n    const { clientX, clientY } = touches ? touches[0] : event;\n    const { x: fromX = clientX, y: fromY = clientY } = startInfo.to || {};\n\n    const startTime = startInfo.time || 0;\n    const offset = { x: clientX - fromX, y: clientY - fromY };\n    const duration = timeStamp - startTime;\n    const velocity = { x: offset.x / duration, y: offset.y / duration };\n\n    return {\n      offset,\n      velocity,\n      to: { x: clientX, y: clientY },\n      time: timeStamp,\n      control: velocity.x < 0 ? 'next' : 'prev',\n    };\n  }\n}\n","/**\n * A root class name.\n */\nconst ROOT = 'virchual';\nconst SLIDE = `${ROOT}__slide`;\nconst PAGINATION = `${ROOT}__pagination`;\nconst PAGINATION_BULLET = `${PAGINATION}-bullet`;\n\n/**\n * The definition table of all classes for elements.\n * They might be modified by options.\n */\nexport const ELEMENT_CLASSES = {\n  slide: SLIDE,\n  slideActive: `${SLIDE}--active`,\n  pagination: PAGINATION,\n  paginationBullet: PAGINATION_BULLET,\n  paginationBulletActive: `${PAGINATION_BULLET}--active`,\n  paginationBulletEdge: `${PAGINATION_BULLET}--edge`,\n};\n","import { Sign } from './types';\nimport { addOrRemoveClass, append, createElement, prepend, remove } from './utils/dom';\nimport { range, rewind } from './utils/utils';\nimport { ELEMENT_CLASSES } from './constants';\n\n/**\n * Map current index to bullet elements index.\n *\n * @param index Current index.\n * @param center Center index of bullets (5 bullets -> center: 2).\n * @param bullets Amount of bullets.\n * @param total Total bullets. Same as amount of slides.\n */\nexport function mapActiveIndex(index: number, center: number, bullets: number, total: number) {\n  if (bullets >= total) {\n    return index;\n  }\n\n  return index - Math.max(index - center, 0) + Math.max(index - (-1 + total - center), 0);\n}\n\n/**\n * Return true if bullet is edge bullet.\n *\n * @param index Index of bullet.\n * @param realIndex Real slide index which bullet represents.\n * @param bullets Amount of shown bullets.\n * @param total Total bullets. Same as amount of slides.\n */\nexport function isEdgeBullet(index: number, realIndex: number, bullets: number, total: number) {\n  const isRightEdge = index === bullets - 1;\n\n  // bullet is either left or right edge\n  if (index === 0) {\n    return index !== realIndex;\n  }\n\n  if (isRightEdge) {\n    return realIndex + 1 < total;\n  }\n\n  return false;\n}\n\n/**\n * Get real index of bullet.\n *\n * @param index Index of bullet.\n * @param currentIndex Current active index.\n * @param activeBulletIndex Index of active bullet element.\n */\nfunction getRealIndex(index: number, currentIndex: number, activeBulletIndex: number) {\n  return currentIndex - activeBulletIndex + index;\n}\n\nexport class Pagination {\n  private _ref: HTMLElement;\n  private _currentIndex = 0;\n  private _centerIndex: number;\n  private _bulletsLength: number;\n  private _diameter: number;\n  private _isActive = true;\n\n  constructor(\n    private _container: HTMLElement,\n    private _totalSlides: number,\n    { diameter, bullets, isActive }: { diameter?: number; bullets?: number; isActive?: boolean } = {},\n  ) {\n    this._ref = _container.querySelector(`.${ELEMENT_CLASSES.pagination}`);\n\n    this._bulletsLength = Math.min(_totalSlides, bullets ?? 5);\n    this._diameter = diameter ?? 16;\n    this._isActive = isActive ?? true;\n\n    this._centerIndex = Math.floor(this._bulletsLength / 2);\n  }\n\n  render() {\n    // quit early, no pagination bullets for less than 2 slides\n    if (!this._isActive || this._totalSlides < 2) {\n      this._isActive = false;\n\n      return;\n    }\n\n    this._ref = createElement('div', { classNames: ELEMENT_CLASSES.pagination });\n\n    this._ref.style.width = `${this._bulletsLength * this._diameter}px`;\n    this._ref.style.height = `${this._diameter}px`;\n\n    range(0, Math.min(this._bulletsLength, this._totalSlides) - 1).forEach(index => {\n      const isEdge = isEdgeBullet(index, index, this._bulletsLength, this._totalSlides);\n\n      const bullet = this._renderBullet(index, { isEdge, isActive: index === this._currentIndex });\n\n      append(this._ref, bullet);\n    });\n\n    append(this._container, this._ref);\n  }\n\n  next() {\n    this._goTo(+1);\n  }\n\n  prev() {\n    this._goTo(-1);\n  }\n\n  private _goTo(sign: Sign) {\n    if (!this._isActive) {\n      return;\n    }\n\n    this._currentIndex = rewind(this._currentIndex + sign, this._totalSlides - 1);\n\n    const mappedActiveIndex = mapActiveIndex(this._currentIndex, this._centerIndex, this._bulletsLength, this._totalSlides);\n    const overflowRight = this._currentIndex + this._centerIndex + (sign > 0 ? 0 : 1) < this._totalSlides;\n    const overflowLeft = this._currentIndex - this._centerIndex > 0;\n    const removeBullet = mappedActiveIndex === this._centerIndex && (sign > 0 ? overflowLeft : overflowRight);\n\n    let removeBulletIndex = -1;\n\n    if (removeBullet) {\n      removeBulletIndex = sign === 1 ? 0 : this._bulletsLength - 1;\n    }\n\n    const bullets = [].slice.call(this._ref.querySelectorAll('span')) as HTMLElement[];\n\n    bullets.forEach((bullet, index) => {\n      this._handleBulletMovement({ bullet, index, sign, removeBullet, removeBulletIndex, activeIndex: mappedActiveIndex });\n    });\n\n    // append or prepend new bullet\n    if (removeBullet) {\n      const insertBulletIndex = -1 + this._bulletsLength - removeBulletIndex;\n      const realIndex = getRealIndex(insertBulletIndex, this._currentIndex, mappedActiveIndex);\n      const isEdge = isEdgeBullet(insertBulletIndex, realIndex, this._bulletsLength, this._totalSlides);\n\n      const bullet = this._renderBullet(insertBulletIndex, { isEdge });\n\n      this._insertBullet(sign, bullet);\n    }\n  }\n\n  private _handleBulletMovement({\n    bullet,\n    index,\n    activeIndex,\n    sign,\n    removeBullet,\n    removeBulletIndex,\n  }: {\n    bullet: HTMLElement;\n    index: number;\n    activeIndex: number;\n    sign: Sign;\n    removeBullet: boolean;\n    removeBulletIndex: number;\n  }) {\n    if (removeBulletIndex === index) {\n      remove(bullet);\n\n      return;\n    }\n\n    // shift index due to remove bullet\n    index = index - (removeBullet ? sign : 0);\n\n    const realIndex = getRealIndex(index, this._currentIndex, activeIndex);\n    const isEdge = isEdgeBullet(index, realIndex, this._bulletsLength, this._totalSlides);\n\n    this._setAttributes(bullet, {\n      isEdge,\n      isActive: index === activeIndex,\n      position: removeBullet ? index * this._diameter : undefined,\n    });\n  }\n\n  private _renderBullet(index: number, { isActive, isEdge }: { isActive?: boolean; isEdge?: boolean } = {}) {\n    const element = createElement('span', { classNames: ELEMENT_CLASSES.paginationBullet });\n\n    this._setAttributes(element, { isActive, isEdge, position: index * this._diameter });\n\n    return element;\n  }\n\n  private _setAttributes(bullet: HTMLElement, { isActive, isEdge, position }: { isActive: boolean; isEdge: boolean; position?: number }) {\n    addOrRemoveClass(bullet, ELEMENT_CLASSES.paginationBulletActive, !isActive);\n    addOrRemoveClass(bullet, ELEMENT_CLASSES.paginationBulletEdge, !isEdge);\n\n    if (position != null) {\n      bullet.style.transform = `translateX(${position}px)`;\n    }\n  }\n\n  private _insertBullet(sign: Sign, bullet: HTMLElement) {\n    const insert = sign === 1 ? append : prepend;\n\n    insert(this._ref, bullet);\n  }\n}\n","import { ELEMENT_CLASSES } from './constants';\n\nimport { identity } from './types';\nimport { addOrRemoveClass, append, prepend as prependFn, remove, createElement } from './utils/dom';\nimport { noop } from './utils/utils';\nimport { ComponentDependencies } from './components/component';\n\n/**\n * Virtual slide component.\n */\nexport class Slide {\n  idx: number;\n  ref: HTMLElement;\n  isMounted = false;\n  isActive = false;\n  isClone = false;\n  position: number;\n\n  private _hasChanged = false;\n  private _html: string;\n  private _isIdle = true;\n  private _transitionEndCallback: identity = noop;\n  private _idleCallback: identity = noop;\n\n  constructor(html: string | HTMLElement, private _frame: HTMLElement, private _imports: ComponentDependencies) {\n    if (typeof html === 'string') {\n      this._html = html;\n\n      return;\n    }\n\n    this.ref = html;\n    this._html = this.ref.innerHTML;\n    this.isMounted = true;\n\n    this._bindEvents();\n  }\n\n  set<T extends Extract<keyof this, 'isActive' | 'position'>>(property: T, value: this[T]) {\n    this[property] = value;\n\n    this._hasChanged = true;\n  }\n\n  /**\n   * Render and mount slide into DOM.\n   *\n   * @param prepend Either prepend slide to frame DOM element or append.\n   */\n  mount(prepend = false) {\n    this._onIdle(() => {\n      if (this.isMounted) {\n        // slide has changed -> update in DOM\n        if (this._hasChanged) {\n          this._update();\n        }\n\n        return;\n      }\n\n      this._render();\n\n      console.debug('[Mount] Slide', this);\n\n      this.isMounted = true;\n\n      this._bindEvents();\n\n      const insert = prepend ? prependFn : append;\n\n      insert(this._frame, this.ref);\n    });\n  }\n\n  /**\n   * Unmount and remove slide from DOM.\n   */\n  unmount() {\n    console.debug('[Unmount] Slide - Start', this);\n\n    this.isMounted = false;\n\n    this._onIdle(() => {\n      this._unbindEvents();\n\n      remove(this.ref);\n\n      console.debug('[Unmount] Slide - End', this);\n    });\n  }\n\n  /**\n   * Clone slide and return clone.\n   *\n   * @returns Cloned slide instance.\n   */\n  clone(): Slide {\n    const slide = new Slide(this._html, this._frame, this._imports);\n\n    slide.isClone = true;\n\n    return slide;\n  }\n\n  /**\n   * Start transition.\n   *\n   * @param value Position to translate to. Unit (px, %,..) has to be given.\n   * @param easing Enable or disable transition easing.\n   * @param done Callback function after transition has ended.\n   */\n  translate(xPosition: string, { easing, done }: { easing?: boolean; done?: identity } = {}) {\n    this._transitionEndCallback = done || noop;\n\n    this._isIdle = easing !== true;\n\n    let value = '';\n\n    if (easing) {\n      value = `transform ${this._imports.virchual.settings['speed']}ms ${this._imports.virchual.settings['easing']}`;\n    }\n\n    this.ref.style.transition = value;\n    this.ref.style.transform = `translate3d(calc(${this.position}% + ${xPosition}), 0, 0)`;\n  }\n\n  private _render(): HTMLElement {\n    this.ref = createElement('div', { classNames: ELEMENT_CLASSES.slide, html: this._html });\n\n    this._setAttributes();\n\n    return this.ref;\n  }\n\n  private _bindEvents() {\n    this._imports.eventBus.on('transitionend', this._onTransitionEnd, this.ref);\n    this._imports.eventBus.on('move', this._onMove);\n  }\n\n  private _unbindEvents() {\n    this._imports.eventBus.off('transitionend', this._onTransitionEnd, this.ref);\n    this._imports.eventBus.off('move', this._onMove);\n  }\n\n  private _update() {\n    console.debug('[Update] Slide', this);\n\n    this._hasChanged = false;\n\n    this._setAttributes();\n  }\n\n  private _setAttributes() {\n    addOrRemoveClass(this.ref, ELEMENT_CLASSES.slideActive, !this.isActive);\n\n    this.translate('0%');\n  }\n\n  /**\n   * Execute callback as soon as slide is idle and all transitions finished.\n   *\n   * @param callback Callback function.\n   */\n  private _onIdle(callback: identity) {\n    // call callback immediately\n    if (this._isIdle) {\n      callback();\n\n      return;\n    }\n\n    this._idleCallback = () => {\n      callback();\n\n      this._resetIdleCallback();\n    };\n  }\n\n  private _resetIdleCallback() {\n    this._idleCallback = noop;\n    this._isIdle = true;\n  }\n\n  private _onTransitionEnd = () => {\n    this.ref.style.transition = '';\n\n    this._idleCallback();\n    this._transitionEndCallback();\n\n    this._resetIdleCallback();\n  };\n\n  private _onMove = () => {\n    this._resetIdleCallback();\n  };\n}\n","export function createElement(tagName: string, { classNames, html }: { classNames?: string; html?: string }) {\n  const element = document.createElement(tagName);\n\n  element.className = classNames;\n  element.innerHTML = html || '';\n\n  return element;\n}\n\n/**\n * Remove a given element from a DOM tree.\n *\n * @param elms - Element(s) to be removed.\n */\nexport function remove(element: HTMLElement) {\n  if (element && element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}\n\n/**\n * Append a child to a given element.\n *\n * @param parent - A parent element.\n * @param child  - An element to be appended.\n */\nexport function append(parent: HTMLElement, child: HTMLElement) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Prepend an element to parent.\n *\n * @param element- An element to prepend.\n * @param element - A reference element.\n */\nexport function prepend(parent: HTMLElement, element: HTMLElement) {\n  if (parent && parent.firstChild && element) {\n    parent.insertBefore(element, parent.firstChild);\n  }\n}\n\n/**\n * Add or remove css class to given element.\n *\n * @param element Element to add class tp.\n * @param klass CSS classname.\n * @param remove Remove class instead of adding.\n */\nexport function addOrRemoveClass(element: HTMLElement, klass: string, remove = false) {\n  if (!remove) {\n    element.classList.add(klass);\n\n    return;\n  }\n\n  element.classList.remove(klass);\n}\n","import { range } from './utils';\n\n/**\n * Returns a sliding window section of an array.\n *\n * @param source Source array.\n * @param start The start of the specified portion of the array. Acts as the center of the sliding window.\n * @param len The window size/length. Specifies how many items the window has on each sides.\n */\nexport function slidingWindow(source: number[], start: number, len: number): number[] {\n  if (source.length < 2) {\n    return source;\n  }\n\n  const left = range(start - len, start - 1).map(index => get(source, index));\n  const center = [source[start]];\n  const right = range(start + 1, start + len).map(index => get(source, index));\n\n  const window = [...left, ...center, ...right];\n\n  return window;\n}\n\n/**\n * Get array item by index.\n *\n * Returning items from the end of the source array when accessing negative indexes or\n * from the start of source array when accessing out of range indexes.\n *\n * @param source Source array.\n * @param index Index of array item to access.\n */\nexport function get<T>(source: T[], index: number): T {\n  if (source.length === 0) {\n    return;\n  }\n\n  const isOutOfLowerBounds = index < 0;\n  const isOutOfUpperBounds = index > source.length - 1;\n  const isOutOfBounds = isOutOfLowerBounds || isOutOfUpperBounds;\n\n  const sign = isOutOfUpperBounds ? -1 : +1;\n  const multiple = Math.max(Math.floor(Math.abs(index) / source.length), 1);\n\n  if (isOutOfBounds) {\n    index += sign * multiple * source.length;\n  }\n\n  return source[index];\n}\n","import { Controls, ControlsSettings } from './../src/components/controls/controls';\nimport { Lazy } from './../src/components/lazy/lazy';\nimport { LazyLoadImage } from './../src/components/lazyload-image/lazyload-image';\nimport { Virchual as VirchualCore, VirchualSettings as VirchualCoreSettings } from './../src/virchual';\n\n// @TODO settings with combined settings from components\nexport type VirchualSettings = VirchualCoreSettings & ControlsSettings;\n\nexport default class Virchual extends VirchualCore {\n  constructor(container: HTMLElement, settings: VirchualSettings = {}) {\n    super(container, settings);\n\n    this.register(Controls, { isEnabled: true });\n    // this.register(Lazy, { threshold: 300 }); @TODO\n    this.register(LazyLoadImage, { lazyload: true });\n  }\n}\n","import { ComponentConstructor } from './components/component';\nimport { Drag } from './drag';\nimport { Pagination } from './pagination';\nimport { Slide } from './slide';\nimport { identity, Sign } from './types';\nimport { assert } from './utils/error';\nimport { Event, stop } from './utils/event';\nimport { slidingWindow } from './utils/sliding-window';\nimport { range, rewind } from './utils/utils';\n\ntype DiffActionMount = {\n  type: 'mount';\n  centerDistance: number;\n};\n\ntype DiffActionUnmount = {\n  type: 'unmount';\n};\n\ntype DiffAction = DiffActionMount | DiffActionUnmount;\n\ntype Diff = {\n  index: number;\n  slideIndex: number;\n  action: DiffAction;\n};\n\nexport type VirchualSettings = {\n  slides?: string[] | (() => string[]);\n  speed?: number;\n  easing?: string;\n  swipeDistanceThreshold?: number;\n  flickVelocityThreshold?: number;\n  flickPower?: number;\n  pagination?: boolean;\n  window?: number;\n};\n\nexport function getSlideByIndex(index: number, slides: Slide[]): Slide {\n  return slides.find(slide => slide.idx === index);\n}\n\nexport class Virchual {\n  frame: HTMLElement;\n  currentIndex = 0;\n\n  private _slides: Slide[] = [];\n  private _virtualSlidesWindow: number[] = [];\n  private _eventBus: Event;\n  private _isBusy = false;\n  private _isEnabled = true;\n  private _pagination: Pagination;\n\n  constructor(public container: HTMLElement, public settings: VirchualSettings = {}) {\n    this.frame = this.container.querySelector('.virchual__frame');\n\n    assert(this.frame, 'Invalid element');\n\n    this.currentIndex = 0;\n    this.settings = {\n      slides: [],\n      speed: 200,\n      swipeDistanceThreshold: 150,\n      flickVelocityThreshold: 0.6,\n      flickPower: 600,\n      easing: 'ease-out',\n      pagination: true,\n      window: 1,\n      ...settings,\n    };\n\n    this._eventBus = new Event();\n\n    const hydratedSlides = this._hydrate();\n    const initializedSlides = this._initSlides();\n\n    this._slides = [...hydratedSlides, ...initializedSlides];\n\n    const clonedSlides = this._createClones();\n\n    this._slides = [...this._slides, ...clonedSlides];\n\n    this.settings['window'] = Math.min(this.settings['window'], Math.max(this.getSlidesLength() - 1, 0));\n\n    this._pagination = new Pagination(this.container, this.getSlidesLength(), { isActive: this.settings.pagination });\n\n    this._pagination.render();\n  }\n\n  /**\n   * Return all slides.\n   *\n   * @param includeClones Whether to include cloned slides or not.\n   * @return Slide objects.\n   */\n  getSlides(includeClones = false): Slide[] {\n    return includeClones ? this._slides : this._slides.filter(slide => !slide.isClone);\n  }\n\n  /**\n   * Return total number of slides.\n   *\n   * @param includeClones Whether to include cloned slides or not.\n   * @return Total number of slides.\n   */\n  getSlidesLength(includeClones = false): number {\n    return this.getSlides(includeClones).length;\n  }\n\n  /**\n   * Register component class.\n   *\n   * @param cls Component class.\n   * @param settings Optional settings.\n   */\n  register<T, U>(cls: ComponentConstructor<T, U>, settings?: U) {\n    new cls({ virchual: this, eventBus: this._eventBus }, settings);\n  }\n\n  /**\n   * Mount components.\n   */\n  mount() {\n    if (this.getSlidesLength() < 2) {\n      return;\n    }\n\n    console.debug('[Mount] Virchual');\n\n    this._mountAndUnmountSlides();\n\n    this._bindEvents();\n\n    new Drag(this.frame, { event: this._eventBus }).mount();\n\n    this._eventBus.emit('mounted');\n  }\n\n  /**\n   * Disable Virchual instance and all user interactions (changing slides)\n   */\n  disable() {\n    this._isEnabled = false;\n  }\n\n  /**\n   * Enable previously disabled Virchual instance. Enable user interaction.\n   */\n  enable() {\n    this._isEnabled = false;\n  }\n\n  /**\n   * Register callback fired on the given event(s).\n   *\n   * @param events An event name. Use space to separate multiple events.\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\n   * @param handler A callback function.\n   * @param elm  Optional. Native event will be listened to when this arg is provided.\n   * @param opts Optional. Options for addEventListener.\n   */\n  on(events: string, handler: identity) {\n    this._eventBus.on(events, handler);\n  }\n\n  /**\n   * Unsubscribe the given event.\n   *\n   * @param events An event name.\n   * @param handler Event handler callback.\n   */\n  off(events: string, handler: identity) {\n    this._eventBus.off(events, handler);\n  }\n\n  /**\n   * Go to previous slide.\n   */\n  prev() {\n    console.debug('[Controls] Previous');\n\n    this._goTo('prev');\n  }\n\n  /**\n   * Go to next slide.\n   */\n  next() {\n    console.debug('[Controls] Next');\n\n    this._goTo('next');\n  }\n\n  /**\n   * Destroy instance, remove DOM events.\n   */\n  destroy() {\n    this._eventBus.destroy();\n\n    this._eventBus.emit('destroy');\n  }\n\n  private _goTo(control: 'prev' | 'next') {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    const sign: Sign = control === 'prev' ? -1 : +1;\n    const nextIndex = this.currentIndex + sign * 1;\n    const newIndex = rewind(nextIndex, this.getSlidesLength() - 1);\n    const isRewind = newIndex !== nextIndex;\n    const positionX = `${sign * -100}%`;\n\n    const handleGoTo = () => {\n      this._isBusy = false;\n      this.currentIndex = newIndex;\n\n      this._mountAndUnmountSlides({\n        control: control,\n      });\n\n      const move = control === 'prev' ? this._pagination.prev.bind(this._pagination) : this._pagination.next.bind(this._pagination);\n\n      move();\n\n      this._eventBus.emit('move', { index: this.currentIndex, control });\n    };\n\n    // if rewind necessary, delay further processing until movement has finished\n    if (isRewind) {\n      this._move(positionX, sign, { callback: handleGoTo });\n    } else {\n      this._move(positionX, sign);\n\n      handleGoTo();\n    }\n  }\n\n  /**\n   * Initialize slides.\n   */\n  private _initSlides(): Slide[] {\n    let rawSlides;\n\n    const slides = this.settings['slides'];\n\n    if (typeof slides === 'function') {\n      rawSlides = slides();\n    } else {\n      rawSlides = slides;\n    }\n\n    return (rawSlides || []).map(slide => new Slide(slide, this.frame, { virchual: this, eventBus: this._eventBus }));\n  }\n\n  /**\n   * Hydrate existing slides from DOM.\n   */\n  private _hydrate(): Slide[] {\n    const slideElements = [].slice.call(this.frame.children) as HTMLDivElement[];\n\n    return slideElements.map(element => new Slide(element, this.frame, { virchual: this, eventBus: this._eventBus }));\n  }\n\n  /**\n   * Create clones of slides in case there are less slides than window size.\n   */\n  private _createClones(): Slide[] {\n    const slidesLength = this.getSlidesLength();\n    const totalSlidingWindowLength = this.settings['window'] * 2 + 1;\n    const clones: Slide[] = [];\n\n    // no need to clones slides\n    if (slidesLength >= totalSlidingWindowLength) {\n      return clones;\n    }\n\n    for (let index = slidesLength - 1; index >= slidesLength - this.settings['window']; index--) {\n      const slide = this._slides[index];\n\n      const clone = slide.clone();\n\n      clones.push(clone);\n    }\n\n    return clones;\n  }\n\n  /**\n   * Mount and unmount slides.\n   */\n  private _mountAndUnmountSlides({ control }: { control?: 'prev' | 'next' } = {}) {\n    const window = this.settings['window'];\n    const indicesWithoutClones = range(0, this.getSlidesLength() - 1);\n    const indices = range(0, this.getSlidesLength(true) - 1);\n\n    const virtualSlidesWindow = slidingWindow(indices, this.currentIndex, window);\n    const virtualSlidesWindowWithoutClones = slidingWindow(indicesWithoutClones, this.currentIndex, window);\n\n    const diffs = this._diff(virtualSlidesWindow, this._virtualSlidesWindow);\n\n    diffs.forEach(diff => {\n      const slideIndex = diff['slideIndex'];\n      const realSlideIndex = virtualSlidesWindowWithoutClones[diff.index];\n      const isActive = slideIndex === this.currentIndex;\n      let slide = getSlideByIndex(slideIndex, this._slides) || this._slides[slideIndex];\n\n      // mount\n      if (diff.action.type === 'mount') {\n        const prepend = control === 'prev' || diff.action.centerDistance < 0;\n\n        // clone new slide\n        if (slide == null) {\n          slide = this._slides[realSlideIndex].clone();\n\n          this._slides.splice(slideIndex, 0, slide);\n        }\n\n        slide.idx = slideIndex;\n        slide.set('isActive', isActive);\n        slide.set('position', diff.action.centerDistance * 100);\n\n        slide.mount(prepend);\n\n        // unmount\n      } else {\n        slide.unmount();\n\n        if (slide.isClone) {\n          this._slides.splice(slideIndex, 1);\n        }\n      }\n    });\n\n    this._virtualSlidesWindow = virtualSlidesWindow;\n  }\n\n  private _diff(current: number[], previous: number[]): Diff[] {\n    previous = previous || [];\n\n    const diffs: Diff[] = [\n      // unmount\n      ...this._calculateDiff(previous, current, (isFound, diff) => {\n        if (!isFound) {\n          diff.action.type = 'unmount';\n\n          return diff;\n        }\n      }),\n\n      // mount\n      ...this._calculateDiff(current, []),\n    ];\n\n    return diffs;\n  }\n\n  private _calculateDiff(arrayA: number[], arrayB: number[], condition?: (isFound: boolean, diff: Diff) => Diff): Diff[] {\n    const diffs: Diff[] = [];\n\n    arrayA.forEach((slideIndex, index) => {\n      let diff: Diff = {\n        index,\n        slideIndex,\n        action: {\n          type: 'mount',\n          centerDistance: index - Math.floor(arrayA.length / 2),\n        },\n      };\n\n      const left = arrayB[index - 1] - slideIndex;\n      const right = arrayB[index + 1] - slideIndex;\n      const isFound = left === 0 || right === 0;\n\n      diff = condition != null ? condition(isFound, diff) : diff;\n\n      diff && diffs.push(diff);\n    });\n\n    return diffs;\n  }\n\n  private _bindEvents() {\n    this._eventBus.on('drag', this._onDrag);\n    this._eventBus.on('dragend', this._onDragEnd);\n    this._eventBus.on('click', this._onClick, this.frame, { capture: true });\n  }\n\n  /**\n   * Called when frame is clicked.\n   *\n   * @param event A click event.\n   */\n  private _onClick = (event: MouseEvent) => {\n    this._isBusy && stop(event);\n  };\n\n  /**\n   * Handle drag event.\n   *\n   * @param event\n   */\n  private _onDrag = (event: { offset: { x: number; y: number }; control: 'prev' | 'next' }) => {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    this._isBusy = true;\n\n    const sign = event.control === 'prev' ? -1 : +1;\n    const positionX = -1 * sign * Math.abs(event.offset.x);\n\n    this._move(`${Math.round(positionX)}px`, sign, { easing: false });\n  };\n\n  /**\n   * Handle dragged event.\n   *\n   * @param event\n   */\n  private _onDragEnd = (event: { control: 'prev' | 'next' }) => {\n    console.debug('[Drag] Drag end', event);\n\n    this._goTo(event.control);\n  };\n\n  /**\n   * Move slides to their new position.\n   *\n   * @param xPosition New slide position. Unit (px, %,..) has to be given.\n   * @param sign Direction. Either -1 or +1.\n   * @param callback Callback function which is called after moving has finished.\n   */\n  private _move(xPosition: string, sign: Sign, { easing, callback }: { easing?: boolean; callback?: identity } = {}) {\n    let mountableSlideIndices = slidingWindow(range(0, this.getSlidesLength(true) - 1), this.currentIndex, this.settings['window']);\n\n    if (sign > 0) {\n      mountableSlideIndices = mountableSlideIndices.slice(-1 * (this.settings['window'] + 1));\n    } else {\n      mountableSlideIndices = mountableSlideIndices.slice(0, this.settings['window'] + 1);\n    }\n\n    mountableSlideIndices.forEach(slideIndex => {\n      const slide = this._slides[slideIndex];\n\n      slide.translate(xPosition, {\n        easing: easing ?? true,\n        done: () => {\n          if (callback) {\n            callback();\n\n            callback = null;\n          }\n        },\n      });\n    });\n  }\n}\n","/**\n * Check existence of the given object and throw an error if it doesn't.\n *\n * @throws {Error}\n *\n * @param subject - A subject to be confirmed.\n * @param message - An error message.\n */\nexport function assert<T extends unknown>(subject: T, message: string) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n"],"names":["Event","Controls","noop","LOADING_CLASSNAME","LazyLoadImage","Drag","SLIDE","ELEMENT_CLASSES","Pagination","Slide","stop","e","cancelable","preventDefault","stopImmediatePropagation","stopPropagation","createElement","tagName","classNames","html","element","document","className","innerHTML","remove","parentElement","removeChild","append","parent","child","appendChild","prepend","firstChild","insertBefore","addOrRemoveClass","klass","classList","add","range","start","end","Array","fill","map","_","idx","rewind","index","edge","slidingWindow","source","len","left","center","right","length","get","isOutOfUpperBounds","isOutOfBounds","sign","multiple","Math","max","floor","abs","isPictureTag","nodeName","toLowerCase","getImage","image","picture","parentNode","isEdgeBullet","realIndex","bullets","total","getRealIndex","currentIndex","activeBulletIndex","this","on","events","handler","opts","event","split","forEach","_this","_addEvent","off","target","_this2","_removeEvent","emit","_handlers","item","elm","destroy","_unroll","removeEventListener","addEventListener","push","filter","_this3","_imports","_settings","closest","dataset","controls","virchual","next","prev","_controls","slice","call","container","querySelectorAll","mount","button","eventBus","_onClick","LAZY_CLASSNAME","lazyloadSelector","_completeLoading","lazyload","_lazyload","_lazyloadSelector","mounted","_doLazyLoad","move","_getImages","_loadImage","slidesWindowIndices","getSlides","images","slide","isMounted","ref","img","hasLazyImages","srcSetData","srcset","srcData","src","setAttribute","removeAttribute","_this4","_getEvents","load","_onLoad","error","_onError","_frame","_isDragging","_startInfo","_analyze","_currentInfo","_eventBus","_shouldMove","_goTo","_onStart","passive","_onMove","_onEnd","offset","atan","y","x","PI","info","velocity","startInfo","timeStamp","touches","clientX","clientY","to","duration","time","control","slideActive","pagination","ROOT","paginationBullet","PAGINATION","paginationBulletActive","PAGINATION_BULLET","paginationBulletEdge","_container","_totalSlides","diameter","isActive","_ref","querySelector","_bulletsLength","min","_diameter","_isActive","_centerIndex","render","style","width","height","isEdge","bullet","_renderBullet","_currentIndex","mappedActiveIndex","removeBullet","removeBulletIndex","insertBulletIndex","_handleBulletMovement","activeIndex","_insertBullet","_setAttributes","position","undefined","transform","transition","_idleCallback","_transitionEndCallback","_resetIdleCallback","_html","_bindEvents","set","property","value","_hasChanged","_onIdle","_update","_render","prependFn","unmount","_unbindEvents","clone","isClone","translate","xPosition","easing","done","_isIdle","settings","_onTransitionEnd","callback","register","isEnabled","hydratedSlides","initializedSlides","clonedSlides","_isBusy","positionX","_isEnabled","_move","round","frame","subject","Error","assert","slides","speed","swipeDistanceThreshold","flickVelocityThreshold","flickPower","window","_hydrate","_initSlides","_slides","_createClones","getSlidesLength","_pagination","includeClones","cls","_mountAndUnmountSlides","disable","enable","nextIndex","newIndex","handleGoTo","bind","children","slidesLength","clones","indicesWithoutClones","virtualSlidesWindow","virtualSlidesWindowWithoutClones","_diff","_virtualSlidesWindow","diff","slideIndex","realSlideIndex","_this5","find","action","type","centerDistance","splice","current","previous","_calculateDiff","isFound","arrayA","arrayB","condition","diffs","_onDrag","_onDragEnd","capture","mountableSlideIndices","_this6"],"mappings":"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"}